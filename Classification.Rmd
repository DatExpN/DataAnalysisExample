Предобработка данных. 
Нужно перекодировать переменную Genre (так как у одного фильма одновременно может быть указано несколько жанров): создадим новую переменную, которая будет нести информацию о первом (основном) из указанных жанров. Наиболее часто появляющимися жанрами в этой базе являются Drama, Comedy, Action, Crime, все остальные жанры объединим в категорию Other (объединяем в большую группу, так как присутствующее число наблюдений по этим категориям не достаточно для анализа)
Нужно перекодировать переменную Runtime, чтобы осталось только число минут для каждого фильма.
Несколько переменных содержат пропущенные значения, заменим их на медианные значения.
Для анализа нам также понадобятся новые переменные: выручка больше или равная медианному значению, год релиза позже или равный медианному значению, оценка критиков больше или равная медианному значению, оценка аудитории больше или равная медианному значению.
Основными переменными для анализа в этой базе для нас будут: год релиза, длительность фильма, жанр, рейтинг среди аудитории, рейтинг среди критиков и выручка.
```{r}
library(readr)
imdb_top_1000 <- read_csv("C:/Users/Nadezhda/Desktop/imdb_top_1000.csv")
df <- imdb_top_1000[, c(3, 5:7, 9, 16)] 
library(stringr)
df[c('Time', 'Last')] <- str_split_fixed(df$Runtime, ' ', 2) 
df[c('Genre1', 'Genre2', 'Genre3')] <- str_split_fixed(df$Genre, ',', 3)
sapply(df, class) 
cols.num <- c('Released_Year', 'Time')
df[cols.num] <- sapply(df[cols.num], as.numeric)
names(which(colSums(is.na(df))>0)) 
df$Gross[is.na(df$Gross)]<- median(df$Gross,na.rm = TRUE)
df$Meta_score[is.na(df$Meta_score)]<- median(df$Meta_score,na.rm = TRUE)
df$Released_Year[is.na(df$Released_Year)]<- median(df$Released_Year,na.rm = TRUE)
df$Revenue <- with(df, ifelse(Gross >= 23530892, 1, 0))
df$Rating <- with(df, ifelse(IMDB_Rating >= 7.9, 1, 0))
df$Year <- with(df, ifelse(Released_Year >= 1999, 1, 0))
df$Critics <- with(df, ifelse(Meta_score >= 79, 1, 0))
df$MainGenre <- with(df, ifelse(Genre1 == 'Drama' | Genre1 == 'Comedy' | Genre1 == 'Action' | Genre1 == 'Crime', Genre1, 'Other'))
cols.char <- c('Genre1', 'Genre2', 'Genre3', 'MainGenre', 'Revenue', 'Rating', 'Year', 'Critics')
df[cols.char] <- lapply(df[cols.char], factor)
sapply(df, class)
df <- df[, c(1, 4:7, 12:16)]
```
Далее мы будем решать задачу классификации фильмов, представленных в этой базе. Эту задачу мы будем решать при помощи кластерного анализа. Однако до перехода к кластерному анализу, посмотрим при помощи визуального анализа на какие группы потенциально могут быть разделены фильмы. 
Для решения этой задачи по визуализации воспользуемся алгоритмом многомерного шкалирования. Многомерное шкалирование хорошо подходит для задач визуального отображения близости между объектами, помещенными в двумерное пространство. Для такой визуализации возьмем три переменных из нашей базы - рейтинг критиков, рейтинг аудитории и доход. Одной из базовых гипотез может быть предположение о том, что наша выборка в 1000 фильмов разделится на группу, включающие фильмы с высоким рейтингом и большой выручкой и группу, объединяющую фильмы с низким рейтингом и маленькой выручкой.
```{r}
df_stand <- as.data.frame(scale(df[, 2:4])) # переменные измерены в разных шкалах, требуется стандартизация
library(vegan)
nmds_result <- metaMDS(df_stand, distance = 'euclidean', k = 2)
nmds_result$stress # показатель говорит о том, насколько хорошо двумерное пространство подходит для отображения наших данных, то есть с какой точностью сработал алгоритм для наших данных (stress < 0.2 означает, что решение на два измерения хорошо подходит)
data_scores <- as.data.frame(scores(nmds_result))
data_scores <- cbind(data_scores, df[, 6:10])
```
Визуализируем наши данные при помощи координат, которые мы получили.
```{r}
library(ggplot2)
ggplot() +
geom_point(data = data_scores, aes(x = NMDS1, y = NMDS2, color = Rating), size = 2.5, alpha = 0.6) +
annotate(geom = 'label', x = -1, y = 5.5, size = 9.5, label = paste('Stress: ', round(nmds_result$stress, digits = 2))) +
scale_color_discrete(name = "Audience Rating", labels = c('lower than 7.9', '7.9 or higher'))
ggplot() +
geom_point(data = data_scores, aes(x = NMDS1, y = NMDS2, color = Critics), size = 2.5, alpha = 0.6) +
annotate(geom = 'label', x = -1, y = 5.5, size = 9.5, label = paste('Stress: ', round(nmds_result$stress, digits = 2))) +
scale_color_discrete(name = "Critics Rating", labels = c('lower than 79', '79 or higher'))
![](https://github.com/DatExpN/DataAnalysisExample/blob/main/RPlot1.png)
![](https://github.com/DatExpN/DataAnalysisExample/blob/main/RPlot2.png)
```
